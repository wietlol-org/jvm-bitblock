package me.wietlol.bitblock.codegenerator.generators.kotlin

import me.wietlol.bitblock.api.serialization.DeserializationContext
import me.wietlol.bitblock.api.serialization.ModelSerializer
import me.wietlol.bitblock.api.serialization.Schema
import me.wietlol.bitblock.api.serialization.SerializationContext
import me.wietlol.bitblock.codegenerator.data.models.BitModel
import me.wietlol.bitblock.codegenerator.data.models.BitModule
import me.wietlol.bitblock.codegenerator.data.models.DefaultBitModelType.Companion.blueprint
import me.wietlol.bitblock.codegenerator.generators.CodeGeneratorOptions
import me.wietlol.bitblock.codegenerator.utils.bitBlockVersion
import me.wietlol.tomplot.kotlin.builders.body
import me.wietlol.tomplot.kotlin.builders.ktComment
import me.wietlol.tomplot.kotlin.builders.ktCustomCode
import me.wietlol.tomplot.kotlin.builders.ktDirectGenericTypeArgument
import me.wietlol.tomplot.kotlin.builders.ktDirectTypeReference
import me.wietlol.tomplot.kotlin.builders.ktFunction
import me.wietlol.tomplot.kotlin.builders.ktImport
import me.wietlol.tomplot.kotlin.builders.ktImportedTypeReference
import me.wietlol.tomplot.kotlin.builders.ktObject
import me.wietlol.tomplot.kotlin.builders.ktPackage
import me.wietlol.tomplot.kotlin.builders.ktParameter
import me.wietlol.tomplot.kotlin.builders.ktProperty
import me.wietlol.tomplot.kotlin.builders.ktRawCodeExpression
import me.wietlol.tomplot.kotlin.builders.ktStarGenericTypeArgument
import me.wietlol.tomplot.kotlin.builders.nullable
import me.wietlol.tomplot.kotlin.data.models.DefaultKtVisibility.Companion.private
import me.wietlol.tomplot.kotlin.engine.KotlinTomplotEngine
import java.io.File
import java.io.InputStream
import java.io.OutputStream
import java.util.*

class KotlinSerializerGenerator(
	val engine: KotlinTomplotEngine<*>
)
{
	companion object : KotlinGeneratorHelper
	
	fun generateSerializers(bitModule: BitModule, implRoot: File, options: CodeGeneratorOptions)
	{
		val relativePath = (bitModule.implRootPackage + bitModule.serializerPackage).replace(".", "/")
		val implFolder = implRoot.resolve(relativePath)
		
		options.logger("exporting model serializers to     ${implFolder.absolutePath}")
		
		implFolder.mkdirs()
		
		bitModule.models
			.filter { it.type == blueprint }
			.filter { it.isMutable().not() }
			.forEach { generateSerializer(bitModule, it, implRoot, options) }
	}
	
	private fun generateSerializer(bitModule: BitModule, bitModel: BitModel, implRoot: File, options: CodeGeneratorOptions)
	{
		val serializerName = "${bitModel.name}Serializer"
		engine.createScript(serializerName, implRoot) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.implRootPackage + bitModule.serializerPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			if (bitModule.useExistingModels.not())
				ktImport("${bitModule.apiRootPackage}${bitModule.apiModelPackage}.${bitModel.name}")
			ktImport("${bitModule.implRootPackage}${bitModule.builderPackage}.${bitModel.name}Builder")
			ktImport("me.wietlol.utils.common.streams.writeUnsignedVarInt")
			ktImport("me.wietlol.utils.common.streams.readUnsignedVarInt")
			ktImport("me.wietlol.bitblock.api.serialization.deserialize")
			
			if (options.internalBuilders)
			{
				ktImport("${bitModule.apiRootPackage}${bitModule.apiModelPackage}.*")
				ktImport("${bitModule.implRootPackage}${bitModule.implModelPackage}.*")
			}
			
			ktCustomCode("70v0f9")
			
			val targetType = bitModel.asReference()
				.let {
					ktDirectTypeReference(
						it.path,
						it.genericTypeArguments.map { ktStarGenericTypeArgument() },
						it.isNullable
					)
				}
			
			ktObject(serializerName) {
				superTypes = mutableListOf(
					ktImportedTypeReference(
						ModelSerializer::class,
						listOf(
							ktDirectGenericTypeArgument(targetType),
							ktDirectGenericTypeArgument(targetType),
						)
					)
				)
				
				val serializeProperties = bitModel
					.getExtendedNoValueProperties(bitModule)
					.plus(bitModel.properties.filter { it.isSerialized })
					.filter { it.isTransient.not() }
				
				ktProperty(
					"endOfObject",
					ktImportedTypeReference(Int::class),
					visibility = private,
					initialValue = ktRawCodeExpression("0")
				)
				serializeProperties.forEach {
					val index = it.index
						?: throw IllegalStateException("broken")
					
					ktProperty(
						"${it.name}Index",
						ktImportedTypeReference(Int::class),
						visibility = private,
						initialValue = ktRawCodeExpression(index.toString())
					)
				}
				
				ktProperty(
					"modelId",
					ktImportedTypeReference(UUID::class),
					isOverride = true,
					getter = ktRawCodeExpression("${bitModel.name}.serializationKey")
				)
				
				ktProperty(
					"dataClass",
					ktImportedTypeReference(Class::class, listOf(ktDirectGenericTypeArgument(targetType))),
					isOverride = true,
					getter = ktRawCodeExpression("${bitModel.name}::class.java")
				)
				ktFunction("serialize") {
					parameters = mutableListOf(
						ktParameter("serializationContext", ktImportedTypeReference(SerializationContext::class)),
						ktParameter("stream", ktImportedTypeReference(OutputStream::class)),
						ktParameter("schema", ktImportedTypeReference(Schema::class)),
						ktParameter("entity", targetType),
					)
					
					isOverride = true
					
					body {
						if (bitModel.isReferenceSensitive)
						{
							appendLine("val (key, isNewlyRegistered) = serializationContext.registerBitReference(entity)")
							appendLine("stream.writeUnsignedVarInt(key)")
							appendLine("if (isNewlyRegistered.not())")
							indented {
								appendLine("return")
							}
							appendLine()
						}
						
						serializeProperties.forEach {
							if (it.type.isOptional)
							{
								appendLine("entity.${escapeName(it.name)}?.also {")
								indented {
									appendLine("stream.writeUnsignedVarInt(${it.name}Index)")
									appendLine("schema.serialize(serializationContext, stream, it)")
								}
								appendLine("}")
								appendLine()
							}
							else
							{
								appendLine("stream.writeUnsignedVarInt(${it.name}Index)")
								appendLine("schema.serialize(serializationContext, stream, entity.${escapeName(it.name)})")
								appendLine()
							}
						}
						
						appendLine("stream.writeUnsignedVarInt(endOfObject)")
					}
				}
				
				ktFunction("deserialize") {
					parameters = mutableListOf(
						ktParameter("deserializationContext", ktImportedTypeReference(DeserializationContext::class)),
						ktParameter("stream", ktImportedTypeReference(InputStream::class)),
						ktParameter("schema", ktImportedTypeReference(Schema::class)),
					)
					returnType = targetType
					
					isOverride = true
					
					
					body {
						if (bitModel.isReferenceSensitive)
						{
							appendLine("val referenceKey = stream.readUnsignedVarInt()")
							appendLine("val reference = deserializationContext.loadBitReference(referenceKey)")
							appendLine("if (reference != null)")
							indented {
								append("return reference as ")
								append(bitModel.name)
								if (bitModel.generics.isNotEmpty())
								{
									append("<")
									appendJoin(bitModel.generics, ", ") { append("*") }
									append(">")
								}
								appendLine()
							}
						}
						
						val noValueProperties = bitModel.getExtendedNoValueProperties(bitModule)
						if (options.internalBuilders)
						{
							noValueProperties.forEach {
								append("var ")
								append(escapeName(it.name))
								append(": ")
								appendTypeReference(it.type.toKotlin(bitModule, true).nullable())
								append(" = ")
								when
								{
									it.type.isCollective() && it.type.isOptional.not() -> append(newCollectionFor(it.type))
									it.defaultValue != null -> append(it.defaultValue!!.toKotlin())
									else -> append("null")
								}
								appendLine()
							}
						}
						else
						{
							append("val builder = ${bitModel.name}Builder")
							if (bitModel.generics.isNotEmpty())
							{
								append("<")
								appendJoin(bitModel.generics, ", ") { append("Any") }
								append(">")
							}
							appendLine("()")
						}
						
						appendLine()
						appendLine("while (true)")
						appendLine("{")
						indented {
							appendLine("when (stream.readUnsignedVarInt())")
							appendLine("{")
							indented {
								append("endOfObject -> return ")
								if (options.internalBuilders)
								{
									val builderFacade = bitModule.builderFacade
									when
									{
										builderFacade != null ->
										{
											append(builderFacade)
											append(".build")
											append(bitModel.name)
											appendLine("(")
										}
										else ->
										{
											val mutableName = bitModel.mutableVariant
												?.takeIf { it.isNotBlank() }
												?: bitModule.mutableModelNameFormat.replace("%", bitModel.name)
											val name = if (bitModel.mutableVariant == null) bitModel.name else mutableName
											
											append(bitModule.implementationNameFormat.replace("%", name))
											appendLine("(")
										}
									}
									
									indented {
										noValueProperties
											.map {
												escapeName(it.name)
													.plus(if (it.type.isOptional.not()) "!!" else "")
													.plus(
														if (it.type.isCollective())
															"${if (it.type.isOptional) "?" else ""}.${if (it.type.isNativelyImmutable()) toImmutableCollectionFor(it.type) else toMutableCollectionFor(it.type)}"
														else
															""
													)
											}
											.forEach { appendLine("$it,") }
									}
									appendLine(")")
								}
								else
								{
									appendLine("builder.build()")
								}
								
								if (bitModel.isReferenceSensitive)
								{
									indented {
										appendLine(".also {")
										indented {
											appendLine("deserializationContext.registerBitReference(referenceKey, it)")
										}
										appendLine("}")
									}
								}
								serializeProperties.forEach {
									appendLine("${it.name}Index -> ${if (options.internalBuilders) "" else "builder."}${escapeName(it.name)} = schema.deserialize(deserializationContext, stream)")
								}
								appendLine("else -> schema.deserialize<Any>(deserializationContext, stream)")
							}
							appendLine("}")
						}
						appendLine("}")
					}
				}
				
				ktCustomCode("5CFs54")
			}
		}
	}
}
