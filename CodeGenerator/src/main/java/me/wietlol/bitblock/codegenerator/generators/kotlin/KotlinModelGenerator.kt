package me.wietlol.bitblock.codegenerator.generators.kotlin

import me.wietlol.bitblock.api.serialization.BitSerializable
import me.wietlol.bitblock.codegenerator.data.models.BitModel
import me.wietlol.bitblock.codegenerator.data.models.BitModule
import me.wietlol.bitblock.codegenerator.data.models.BitProperty
import me.wietlol.bitblock.codegenerator.data.models.BitValue
import me.wietlol.bitblock.codegenerator.data.models.DefaultBitModelType.Companion.blueprint
import me.wietlol.bitblock.codegenerator.data.models.DefaultBitPropertyType.Companion.property
import me.wietlol.bitblock.codegenerator.data.models.DefaultBitPropertyType.Companion.value
import me.wietlol.bitblock.codegenerator.generators.CodeGeneratorOptions
import me.wietlol.bitblock.codegenerator.utils.bitBlockVersion
import me.wietlol.tomplot.kotlin.builders.KotlinContainerBuilder
import me.wietlol.tomplot.kotlin.builders.KotlinElementBuilder
import me.wietlol.tomplot.kotlin.builders.KtInterfaceBuilder
import me.wietlol.tomplot.kotlin.builders.ktClass
import me.wietlol.tomplot.kotlin.builders.ktComment
import me.wietlol.tomplot.kotlin.builders.ktCompanionObject
import me.wietlol.tomplot.kotlin.builders.ktConstructorParameter
import me.wietlol.tomplot.kotlin.builders.ktCustomCode
import me.wietlol.tomplot.kotlin.builders.ktDirectTypeReference
import me.wietlol.tomplot.kotlin.builders.ktFunction
import me.wietlol.tomplot.kotlin.builders.ktImport
import me.wietlol.tomplot.kotlin.builders.ktImportedTypeReference
import me.wietlol.tomplot.kotlin.builders.ktInterface
import me.wietlol.tomplot.kotlin.builders.ktPackage
import me.wietlol.tomplot.kotlin.builders.ktParameter
import me.wietlol.tomplot.kotlin.builders.ktProperty
import me.wietlol.tomplot.kotlin.builders.ktRawCodeExpression
import me.wietlol.tomplot.kotlin.builders.ktTemplated
import me.wietlol.tomplot.kotlin.builders.nullable
import me.wietlol.tomplot.kotlin.data.models.DefaultKtPropertyType
import me.wietlol.tomplot.kotlin.data.models.DefaultKtPropertyType.Companion.variable
import me.wietlol.tomplot.kotlin.data.models.DefaultKtVisibility.Companion.private
import me.wietlol.tomplot.kotlin.data.models.KtObject
import me.wietlol.tomplot.kotlin.engine.KotlinTomplotEngine
import me.wietlol.utils.common.Jsonable
import java.io.File
import java.util.*

class KotlinModelGenerator(
	val engine: KotlinTomplotEngine<*>,
)
{
	companion object : KotlinGeneratorHelper
	
	fun generateModels(bitModule: BitModule, apiRoot: File, implRoot: File, options: CodeGeneratorOptions)
	{
		val apiRelativePath = (bitModule.apiRootPackage + bitModule.apiModelPackage).replace(".", "/")
		val implRelativePath = (bitModule.implRootPackage + bitModule.implModelPackage).replace(".", "/")
		val apiFolder = apiRoot.resolve(apiRelativePath)
		val implFolder = implRoot.resolve(implRelativePath)
		
		options.logger("exporting model interfaces to      ${apiFolder.absolutePath}")
		options.logger("exporting model implementations to ${implFolder.absolutePath}")
		
		apiFolder.mkdirs()
		implFolder.mkdirs()
		
		bitModule.models.forEach {
			if (it.type == blueprint)
				generateBlueprint(bitModule, it, apiRoot, implRoot, options)
			else
				generateContract(bitModule, it, apiRoot, options)
		}
	}
	
	private fun generateBlueprint(bitModule: BitModule, bitModel: BitModel, apiFolder: File, implFolder: File, options: CodeGeneratorOptions)
	{
		if (bitModel.isMutable())
		{
			generateBlueprintMutableApi(bitModule, bitModel, apiFolder, options)
			generateBlueprintMutableImpl(bitModule, bitModel, implFolder, options)
		}
		else
		{
			generateBlueprintApi(bitModule, bitModel, apiFolder, options)
			generateBlueprintImpl(bitModule, bitModel, implFolder, options)
		}
	}
	
	private fun generateBlueprintApi(bitModule: BitModule, bitModel: BitModel, apiFolder: File, options: CodeGeneratorOptions)
	{
		engine.createScript(bitModel.name, apiFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.apiRootPackage + bitModule.apiModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktImport("me.wietlol.utils.common.emptyHashCode")
			ktImport("me.wietlol.utils.common.with")
			ktImport("me.wietlol.utils.common.toJsonString")
			
			ktCustomCode("gAeCSq")
			
			ktInterface(bitModel.name) {
				generateSuperTypes(this, bitModel)
				
				ktCompanionObject {
					ktProperty(
						"serializationKey",
						ktImportedTypeReference(UUID::class),
						getter = ktRawCodeExpression("UUID.fromString(\"${ktTemplated("serializationKey") { UUID.randomUUID().toString() }}\")")
					)
				}
				
				ktProperty(
					"serializationKey",
					ktImportedTypeReference(UUID::class),
					isOverride = true,
					getter = ktRawCodeExpression("Companion.serializationKey")
				)
				
				val isOverriding = isOverridingFn(bitModule, bitModel)
				
				bitModel.properties.forEach {
					when (it.propertyType)
					{
						value ->
						{
							val defaultExpression = it.defaultValue
								?: TODO("you must specify a value for blueprints with value members")
							ktProperty(
								it.name,
								it.type.toKotlin(bitModule),
								isOverride = isOverriding(it),
								getter = ktRawCodeExpression(defaultExpression.toKotlin())
							)
						}
						property ->
						{
							ktProperty(
								it.name,
								it.type.toKotlin(bitModule),
								isOverride = isOverriding(it),
							)
						}
					}
				}
				
				val extendedProperties = bitModel.getExtendedProperties(bitModule)
				
				ktFunction("isEqualTo") {
					parameters = mutableListOf(
						ktParameter("other", ktImportedTypeReference(Any::class).nullable())
					)
					returnType = ktImportedTypeReference(Boolean::class)
					
					body = mutableListOf(
						ktRawCodeExpression("if (this === other) return true"),
						ktRawCodeExpression("if (other == null) return false"),
						ktRawCodeExpression("if (other !is ${bitModel.name}) return false"),
						ktRawCodeExpression(""),
						*extendedProperties.map {
							ktRawCodeExpression("if (${escapeName(it.name)} != other.${escapeName(it.name)}) return false")
						}.toTypedArray(),
						ktRawCodeExpression(""),
						ktRawCodeExpression("return true"),
					)
				}
				
				ktFunction("computeHashCode") {
					returnType = ktImportedTypeReference(Int::class)
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("emptyHashCode"),
						*extendedProperties.map {
							ktRawCodeExpression("\t.with(${escapeName(it.name)})")
						}.toTypedArray(),
					)
				}
				
				ktFunction("toJson") {
					returnType = ktImportedTypeReference(String::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression(
							"\"\"\"{${extendedProperties.filter { it.isTransient.not() }.asSequence().map { "\"${it.name}\":\${${escapeName(it.name)}.toJsonString()}" }.joinToString(",")}}\"\"\""
						)
					)
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(bitModel.name)
					isOverride = true
				}
				
				ktCustomCode("32T3K8")
			}
		}
	}
	
	private fun generateBlueprintMutableApi(bitModule: BitModule, bitModel: BitModel, apiFolder: File, options: CodeGeneratorOptions)
	{
		engine.createScript(bitModel.name, apiFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.apiRootPackage + bitModule.apiModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktCustomCode("xx0P59")
			
			ktInterface(bitModel.name) {
				generateMutableSuperTypes(this, bitModel, bitModule)
				
				bitModel.properties.forEach {
					when (it.propertyType)
					{
						value ->
						{
							ktProperty(
								it.name,
								it.type.toKotlin(bitModule),
								isOverride = true,
								getter = ktRawCodeExpression(it.defaultValue!!.toKotlin())
							)
						}
						property ->
						{
							ktProperty(
								it.name,
								it.type.toKotlin(bitModule, true),
								isOverride = true,
								type = variable
							)
						}
					}
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(
						bitModel.name,
						listOf(),
						false
					)
					isOverride = true
				}
				
				ktCustomCode("JAxd1Z")
			}
		}
	}
	
	private fun generateBlueprintImpl(bitModule: BitModule, bitModel: BitModel, implFolder: File, options: CodeGeneratorOptions)
	{
		val implName = bitModule.implementationNameFormat.replace("%", bitModel.name)
		engine.createScript(implName, implFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.implRootPackage + bitModule.implModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktImport("${bitModule.apiRootPackage}${bitModule.apiModelPackage}.*")
			
			ktCustomCode("B8CiSn")
			
			ktClass(implName) {
				superTypes = mutableListOf(ktDirectTypeReference(bitModel.name))
				
				val noValueProperties = bitModel.getExtendedNoValueProperties(bitModule)
				
				isDataClass = noValueProperties.isNotEmpty()
				primaryConstructorParameters = noValueProperties
					.map {
						ktConstructorParameter(
							it.name,
							it.type.toKotlin(bitModule, false),
							isOverride = true,
							propertyType = DefaultKtPropertyType.value,
							defaultValueExpression = it.defaultValue?.toKotlin()?.let(::ktRawCodeExpression)
						)
					}
					.toMutableList()
				
				generateValues(bitModel.values, implName)
				
				ktFunction("equals") {
					parameters = mutableListOf(
						ktParameter("other", ktImportedTypeReference(Any::class).nullable())
					)
					returnType = ktImportedTypeReference(Boolean::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("isEqualTo(other)")
					)
				}
				
				ktFunction("hashCode") {
					returnType = ktImportedTypeReference(Int::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("computeHashCode()")
					)
				}
				
				ktFunction("toString") {
					returnType = ktImportedTypeReference(String::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("toJson()")
					)
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(implName)
					isOverride = true
					
					isExpressionBody = true
					
					if (noValueProperties.isEmpty())
					{
						body = mutableListOf(
							ktRawCodeExpression("this")
						)
					}
					else
					{
						body = mutableListOf(
							ktRawCodeExpression("copy("),
							*noValueProperties
								.map { generateDuplicateCall(it) }
								.map { ktRawCodeExpression("\t$it,") }
								.toTypedArray(),
							ktRawCodeExpression(")"),
						)
					}
				}
				
				ktCustomCode("fIpaBB")
			}
		}
	}
	
	private fun generateBlueprintMutableImpl(bitModule: BitModule, bitModel: BitModel, implFolder: File, options: CodeGeneratorOptions)
	{
		val implName = bitModule.implementationNameFormat.replace("%", bitModel.name)
		engine.createScript(implName, implFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.implRootPackage + bitModule.implModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktImport("${bitModule.apiRootPackage}${bitModule.apiModelPackage}.*")
			
			ktCustomCode("i73TG8")
			
			ktClass(implName) {
				superTypes = mutableListOf(ktDirectTypeReference(bitModel.name))
				
				val noValueProperties = bitModel.getExtendedNoValueProperties(bitModule)
				
				isDataClass = noValueProperties.isNotEmpty()
				primaryConstructorParameters = noValueProperties
					.map {
						ktConstructorParameter(
							it.name,
							it.type.toKotlin(bitModule, true),
							isOverride = true,
							propertyType = variable,
							defaultValueExpression = it.defaultValue?.toKotlin()?.let(::ktRawCodeExpression)
						)
					}
					.toMutableList()
				
				generateValues(bitModel.values, implName)
				
				ktFunction("equals") {
					parameters = mutableListOf(
						ktParameter("other", ktImportedTypeReference(Any::class).nullable())
					)
					returnType = ktImportedTypeReference(Boolean::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("isEqualTo(other)")
					)
				}
				
				ktFunction("hashCode") {
					returnType = ktImportedTypeReference(Int::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("computeHashCode()")
					)
				}
				
				ktFunction("toString") {
					returnType = ktImportedTypeReference(String::class)
					isOverride = true
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression("toJson()")
					)
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(implName)
					isOverride = true
					
					isExpressionBody = true
					
					if (noValueProperties.isEmpty())
					{
						body = mutableListOf(
							ktRawCodeExpression("this")
						)
					}
					else
					{
						body = mutableListOf(
							ktRawCodeExpression("copy("),
							*noValueProperties
								.map { generateDuplicateCall(it) }
								.map { ktRawCodeExpression("\t$it,") }
								.toTypedArray(),
							ktRawCodeExpression(")"),
						)
					}
				}
				
				ktCustomCode("rEs6sI")
			}
		}
	}
	
	private fun generateContract(bitModule: BitModule, bitModel: BitModel, apiFolder: File, options: CodeGeneratorOptions)
	{
		if (bitModel.isMutable())
			generateContractMutableApi(bitModule, bitModel, apiFolder, options)
		else
			generateContractApi(bitModule, bitModel, apiFolder, options)
	}
	
	private fun generateContractApi(bitModule: BitModule, bitModel: BitModel, apiFolder: File, options: CodeGeneratorOptions)
	{
		engine.createScript(bitModel.name, apiFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.apiRootPackage + bitModule.apiModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktCustomCode("WTcTph")
			
			ktInterface(bitModel.name) {
				isSealed = true
				
				generateSuperTypes(this, bitModel)
				
				val isOverriding = isOverridingFn(bitModule, bitModel)
				
				bitModel.properties.forEach {
					ktProperty(it.name, it.type.toKotlin(bitModule), isOverride = isOverriding(it))
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(bitModel.name)
					isOverride = true
				}
				
				ktCustomCode("0MOZ71")
			}
		}
	}
	
	private fun generateContractMutableApi(bitModule: BitModule, bitModel: BitModel, apiFolder: File, options: CodeGeneratorOptions)
	{
		engine.createScript(bitModel.name, apiFolder) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.apiRootPackage + bitModule.apiModelPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			ktCustomCode("EF39t8")
			
			ktInterface(bitModel.name) {
				isSealed = true
				
				generateMutableSuperTypes(this, bitModel, bitModule)
				
				bitModel.properties.forEach {
					ktProperty(
						it.name,
						it.type.toKotlin(bitModule, true),
						if (it.propertyType == property)
							variable
						else
							DefaultKtPropertyType.value,
						true,
					)
				}
				
				ktFunction("duplicate") {
					returnType = ktDirectTypeReference(bitModel.name, emptyList(), false)
					isOverride = true
				}
				
				ktCustomCode("RjeYfK")
			}
		}
	}
	
	private fun KotlinElementBuilder<*>.generateSuperTypes(builder: KtInterfaceBuilder, bitModel: BitModel)
	{
		builder.superTypes = bitModel.extends.map {
			convertTypeReference(it)
		}
			.let { listOf(ktImportedTypeReference(BitSerializable::class)) + it }
			.plus(ktImportedTypeReference(Jsonable::class))
			.toMutableList()
	}
	
	private fun generateMutableSuperTypes(builder: KtInterfaceBuilder, bitModel: BitModel, bitModule: BitModule)
	{
		builder.superTypes = bitModel.extends
			.asSequence()
			.map { it.toKotlin(bitModule, false) }
			.toMutableList()
	}
	
	private fun KotlinContainerBuilder<*, in KtObject>.generateValues(values: List<BitValue>, implName: String)
	{
		if (values.isNotEmpty())
		{
			ktCompanionObject {
				values.forEach {
					ktProperty(
						it.name,
						ktDirectTypeReference(implName),
						initialValue = ktRawCodeExpression("${implName}(${it.arguments.joinToString(", ") { it.toKotlin() }})")
					)
				}
			}
		}
	}
	
	private fun isOverridingFn(bitModule: BitModule, bitModel: BitModel) =
		{ property: BitProperty ->
			property.isOverride || bitModel.getInheritedProperties(bitModule).any { it.name == property.name }
		}
}
