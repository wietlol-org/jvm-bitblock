package me.wietlol.bitblock.codegenerator.generators.kotlin

import me.wietlol.bitblock.codegenerator.data.models.BitModel
import me.wietlol.bitblock.codegenerator.data.models.BitModule
import me.wietlol.bitblock.codegenerator.data.models.DefaultBitModelType.Companion.blueprint
import me.wietlol.bitblock.codegenerator.generators.CodeGeneratorOptions
import me.wietlol.bitblock.codegenerator.utils.bitBlockVersion
import me.wietlol.tomplot.kotlin.builders.body
import me.wietlol.tomplot.kotlin.builders.ktClass
import me.wietlol.tomplot.kotlin.builders.ktComment
import me.wietlol.tomplot.kotlin.builders.ktCustomCode
import me.wietlol.tomplot.kotlin.builders.ktDirectTypeReference
import me.wietlol.tomplot.kotlin.builders.ktFunction
import me.wietlol.tomplot.kotlin.builders.ktFunctionTypeReference
import me.wietlol.tomplot.kotlin.builders.ktImport
import me.wietlol.tomplot.kotlin.builders.ktObject
import me.wietlol.tomplot.kotlin.builders.ktPackage
import me.wietlol.tomplot.kotlin.builders.ktParameter
import me.wietlol.tomplot.kotlin.builders.ktProperty
import me.wietlol.tomplot.kotlin.builders.ktRawCodeExpression
import me.wietlol.tomplot.kotlin.builders.nullable
import me.wietlol.tomplot.kotlin.data.models.DefaultKtPropertyType.Companion.variable
import me.wietlol.tomplot.kotlin.engine.KotlinTomplotEngine
import java.io.File

class KotlinBuilderGenerator(
	val engine: KotlinTomplotEngine<*>
)
{
	companion object : KotlinGeneratorHelper
	
	fun generateBuilders(bitModule: BitModule, implRoot: File, options: CodeGeneratorOptions)
	{
		val relativePath = (bitModule.implRootPackage + bitModule.builderPackage).replace(".", "/")
		val implFolder = implRoot.resolve(relativePath)
		
		options.logger("exporting model builders to        ${implFolder.absolutePath}")
		
		implFolder.mkdirs()
		
		bitModule.models
			.filter { it.type == blueprint }
			.filter { it.isMutable().not() }
			.forEach { generateBuilder(bitModule, it, implRoot, options) }
		
		generateModuleBuilder(bitModule, implRoot, options)
	}
	
	private fun generateModuleBuilder(bitModule: BitModule, implRoot: File, options: CodeGeneratorOptions)
	{
		val builderName = "${bitModule.module}BuilderFacade"
		engine.createScript(builderName, implRoot) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.implRootPackage + bitModule.builderPackage)
			
			ktObject(builderName) {
				bitModule.models
					.filter { it.type == blueprint }
					.filter { it.isMutable().not() }
					.forEach {
						ktFunction("build${it.name}") {
							parameters = mutableListOf(
								ktParameter(
									"body",
									ktFunctionTypeReference(emptyList(), scope = ktDirectTypeReference("${it.name}Builder")),
								)
							)
							
							isExpressionBody = true
							body {
								appendLine("${it.name}Builder()")
								indented {
									appendLine(".apply(body)")
									appendLine(".build()")
								}
							}
						}
					}
			}
		}
	}
	
	private fun generateBuilder(bitModule: BitModule, bitModel: BitModel, implRoot: File, options: CodeGeneratorOptions)
	{
		val builderName = "${bitModel.name}Builder"
		engine.createScript(builderName, implRoot) {
			ktComment("Generated by BitBlock version $bitBlockVersion")
			
			`package` = ktPackage(bitModule.implRootPackage + bitModule.builderPackage)
			
			addImportsFromAnnotations(bitModule, bitModel)
			
			if (bitModule.useExistingModels.not())
				ktImport("${bitModule.apiRootPackage}${bitModule.apiModelPackage}.*")
			if (bitModule.builderFacade == null)
			{
				val implName = bitModule.implementationNameFormat.replace("%", bitModel.name)
				ktImport("${bitModule.implRootPackage}${bitModule.implModelPackage}.$implName")
			}
			
			ktCustomCode("f5k3GB")
			
			ktClass(builderName) {
				val noValueProperties = bitModel.getExtendedNoValueProperties(bitModule)
				
				generics = bitModel.generics.map { it.toKotlin(bitModule, isMutable = false, includeVariance = false) }.toMutableList()
				
				noValueProperties.forEach {
					ktProperty(
						it.name,
						it.type.toKotlin(bitModule, true).nullable(),
						type = variable,
						initialValue = when
						{
							it.type.isCollective() && it.type.isOptional.not() -> ktRawCodeExpression(newCollectionFor(it.type))
							it.defaultValue != null -> ktRawCodeExpression(it.defaultValue!!.toKotlin())
							else -> ktRawCodeExpression("null")
						}
					)
				}
				
				ktFunction("build") {
					val mutableName = bitModel.mutableVariant
						?.takeIf { it.isNotBlank() }
						?: bitModule.mutableModelNameFormat.replace("%", bitModel.name)
					val modelName = if (bitModel.mutableVariant == null) bitModel.name else mutableName
					
					returnType = ktDirectTypeReference(modelName)
					
					isExpressionBody = true
					body = mutableListOf(
						ktRawCodeExpression(
							bitModule.builderFacade?.plus(".build${bitModel.name}(")
								?: "${bitModule.implementationNameFormat.replace("%", modelName)}("
						),
						*noValueProperties
							.map {
								escapeName(it.name)
									.plus(
										if (it.type.isOptional.not())
											"!!"
										else
											"")
									.plus(
										if (it.type.isCollective())
											"${if (it.type.isOptional) "?" else ""}.${if (it.type.isNativelyImmutable()) toImmutableCollectionFor(it.type) else toMutableCollectionFor(it.type)}"
										else
											"")
							}
							.map { ktRawCodeExpression("\t$it,") }
							.toTypedArray(),
						ktRawCodeExpression(")"),
					)
				}
				
				ktCustomCode("0ETUWm")
			}
		}
	}
}
